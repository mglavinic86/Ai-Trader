"""
Code Generator for AI Trader Self-Upgrade System.

Uses Claude to generate Python filter code based on proposals.
Includes safety constraints to ensure generated code is safe.

Usage:
    from src.upgrade.code_generator import CodeGenerator

    generator = CodeGenerator()
    code = await generator.generate_filter_code(proposal)
"""

import re
from typing import Optional, List, Dict, Any
from dataclasses import dataclass

from src.upgrade.performance_analyzer import FilterProposal
from src.utils.logger import logger


# Safety constraints for generated code
ALLOWED_IMPORTS = [
    "dataclasses",
    "typing",
    "datetime",
    "math",
    "statistics",
    "collections",
    "functools",
    "re",
]

FORBIDDEN_PATTERNS = [
    r"\bimport\s+os\b",
    r"\bfrom\s+os\b",
    r"\bimport\s+sys\b",
    r"\bfrom\s+sys\b",
    r"\bimport\s+subprocess\b",
    r"\bfrom\s+subprocess\b",
    r"\bimport\s+shutil\b",
    r"\bfrom\s+shutil\b",
    r"\bimport\s+socket\b",
    r"\bfrom\s+socket\b",
    r"\bimport\s+requests\b",
    r"\bfrom\s+requests\b",
    r"\bimport\s+urllib\b",
    r"\bfrom\s+urllib\b",
    r"\bimport\s+http\b",
    r"\bfrom\s+http\b",
    r"\bimport\s+pickle\b",
    r"\bfrom\s+pickle\b",
    r"\bexec\s*\(",
    r"\beval\s*\(",
    r"\bcompile\s*\(",
    r"\b__import__\s*\(",
    r"\bopen\s*\(",
    r"\bfile\s*\(",
    r"\bgetattr\s*\(\s*[^,]+,\s*['\"]__",  # getattr with dunder
    r"\bsetattr\s*\(",
    r"\bdelattr\s*\(",
    r"\bglobals\s*\(",
    r"\blocals\s*\(",
    r"\bvars\s*\(",
    r"\bbreakpoint\s*\(",
    r"\.write\s*\(",
    r"\.read\s*\(",
    r"Path\s*\(",
]


@dataclass
class GenerationResult:
    """Result of code generation."""
    success: bool
    code: str = ""
    filter_name: str = ""
    error: str = ""
    safety_violations: List[str] = None

    def __post_init__(self):
        if self.safety_violations is None:
            self.safety_violations = []


class CodeGenerator:
    """
    Generates Python filter code using Claude.

    Includes safety checks to ensure generated code doesn't:
    - Import dangerous modules (os, sys, subprocess, etc.)
    - Use dangerous functions (exec, eval, open, etc.)
    - Access filesystem or network
    """

    # Template for generated filters
    FILTER_TEMPLATE = '''"""
{description}

Generated by AI Trader Self-Upgrade System.
Pattern: {pattern_type} - {pattern_key}
Generated: {timestamp}
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

from src.upgrade.base_filter import BaseFilter, FilterResult


class {class_name}(BaseFilter):
    """
    {description}

    Pattern Analysis:
    - Type: {pattern_type}
    - Key: {pattern_key}
    - Win Rate: {win_rate}%
    - Total Loss: {total_loss} EUR
    """

    def __init__(self):
        super().__init__(
            name="{filter_name}",
            description="{description}",
            priority={priority},
            filter_type="ai_generated"
        )
        {init_code}

    def check(self, signal_data: dict) -> FilterResult:
        """Check if signal should be blocked based on identified pattern."""
        {check_code}
'''

    def __init__(self):
        self._llm_engine = None

    def _get_llm(self):
        """Lazy load LLM engine."""
        if self._llm_engine is None:
            try:
                from src.analysis.llm_engine import LLMEngine
                self._llm_engine = LLMEngine()
            except Exception as e:
                logger.error(f"Failed to initialize LLM: {e}")
                raise
        return self._llm_engine

    async def generate_filter_code(self, proposal: FilterProposal) -> GenerationResult:
        """
        Generate Python filter code for a proposal.

        Args:
            proposal: The filter proposal with pattern data

        Returns:
            GenerationResult with code or error
        """
        try:
            # Build the full prompt
            system_prompt = self._build_system_prompt()
            user_prompt = self._build_user_prompt(proposal)

            # Call Claude to generate code
            llm = self._get_llm()
            response = await self._call_llm_async(llm, system_prompt, user_prompt)

            if not response:
                return GenerationResult(
                    success=False,
                    error="No response from LLM"
                )

            # Extract code from response
            code = self._extract_code(response)
            if not code:
                return GenerationResult(
                    success=False,
                    error="Could not extract code from response"
                )

            # Check for safety violations
            violations = self._check_safety(code)
            if violations:
                return GenerationResult(
                    success=False,
                    error="Safety violations detected",
                    safety_violations=violations
                )

            # Add required imports if missing
            code = self._ensure_required_imports(code)

            return GenerationResult(
                success=True,
                code=code,
                filter_name=proposal.filter_name
            )

        except Exception as e:
            logger.error(f"Code generation failed: {e}")
            return GenerationResult(
                success=False,
                error=str(e)
            )

    def generate_filter_code_sync(self, proposal: FilterProposal) -> GenerationResult:
        """
        Synchronous version of generate_filter_code.

        Uses the template-based approach without LLM for simpler patterns.
        """
        try:
            pattern = proposal.pattern

            # Generate based on pattern type
            if pattern.pattern_type == "instrument":
                code = self._generate_instrument_filter(proposal)
            elif pattern.pattern_type == "session":
                code = self._generate_session_filter(proposal)
            elif pattern.pattern_type == "regime":
                code = self._generate_regime_filter(proposal)
            elif pattern.pattern_type == "combined":
                code = self._generate_combined_filter(proposal)
            else:
                return GenerationResult(
                    success=False,
                    error=f"Unknown pattern type: {pattern.pattern_type}"
                )

            # Check for safety violations
            violations = self._check_safety(code)
            if violations:
                return GenerationResult(
                    success=False,
                    error="Safety violations detected",
                    safety_violations=violations
                )

            return GenerationResult(
                success=True,
                code=code,
                filter_name=proposal.filter_name
            )

        except Exception as e:
            logger.error(f"Code generation failed: {e}")
            return GenerationResult(
                success=False,
                error=str(e)
            )

    def _generate_instrument_filter(self, proposal: FilterProposal) -> str:
        """Generate filter code for instrument pattern."""
        pattern = proposal.pattern
        class_name = self._to_class_name(proposal.filter_name)

        init_code = f'''self.blocked_instrument = "{pattern.pattern_key}"
        self.block_until = None
        self.consecutive_wins_elsewhere = 0
        self.WINS_TO_UNBLOCK = 5'''

        check_code = f'''instrument = signal_data.get("instrument", "")

        # Check if temporarily unblocked
        if self.block_until and datetime.now() > self.block_until:
            return FilterResult(passed=True)

        if self.consecutive_wins_elsewhere >= self.WINS_TO_UNBLOCK:
            return FilterResult(passed=True)

        if instrument == self.blocked_instrument:
            return FilterResult(
                passed=False,
                reason=f"Instrument {{self.blocked_instrument}} blocked due to poor performance (win rate: {pattern.win_rate:.1f}%)",
                details={{
                    "blocked_instrument": self.blocked_instrument,
                    "pattern_win_rate": {pattern.win_rate:.1f},
                    "pattern_total_loss": {pattern.total_loss:.2f}
                }}
            )

        return FilterResult(passed=True)'''

        return self.FILTER_TEMPLATE.format(
            description=proposal.filter_description,
            pattern_type=pattern.pattern_type,
            pattern_key=pattern.pattern_key,
            timestamp=datetime.now().isoformat(),
            class_name=class_name,
            filter_name=proposal.filter_name,
            win_rate=f"{pattern.win_rate:.1f}",
            total_loss=f"{pattern.total_loss:.2f}",
            priority=20,
            init_code=init_code,
            check_code=check_code
        )

    def _generate_session_filter(self, proposal: FilterProposal) -> str:
        """Generate filter code for session pattern."""
        pattern = proposal.pattern
        class_name = self._to_class_name(proposal.filter_name)

        init_code = f'''self.blocked_session = "{pattern.pattern_key}"'''

        check_code = f'''# Determine current session from timestamp
        timestamp = signal_data.get("timestamp", datetime.now())
        if hasattr(timestamp, "hour"):
            hour = timestamp.hour
        else:
            hour = datetime.now().hour

        # Map hour to session (UTC)
        if 7 <= hour < 16:
            current_session = "london"
        elif 12 <= hour < 21:
            current_session = "newyork"
        elif 0 <= hour < 9:
            current_session = "tokyo"
        else:
            current_session = "sydney"

        if current_session == self.blocked_session:
            return FilterResult(
                passed=False,
                reason=f"Session {{self.blocked_session}} blocked due to poor performance (win rate: {pattern.win_rate:.1f}%)",
                details={{
                    "blocked_session": self.blocked_session,
                    "current_session": current_session,
                    "pattern_win_rate": {pattern.win_rate:.1f}
                }}
            )

        return FilterResult(passed=True)'''

        return self.FILTER_TEMPLATE.format(
            description=proposal.filter_description,
            pattern_type=pattern.pattern_type,
            pattern_key=pattern.pattern_key,
            timestamp=datetime.now().isoformat(),
            class_name=class_name,
            filter_name=proposal.filter_name,
            win_rate=f"{pattern.win_rate:.1f}",
            total_loss=f"{pattern.total_loss:.2f}",
            priority=25,
            init_code=init_code,
            check_code=check_code
        )

    def _generate_regime_filter(self, proposal: FilterProposal) -> str:
        """Generate filter code for regime pattern."""
        pattern = proposal.pattern
        class_name = self._to_class_name(proposal.filter_name)

        init_code = f'''self.blocked_regime = "{pattern.pattern_key}"
        self.min_regime_strength = 60  # Only block when regime is strong'''

        check_code = f'''market_regime = signal_data.get("market_regime", "")
        regime_strength = signal_data.get("regime_strength", 0)

        # Get from technical dict if not at top level
        technical = signal_data.get("technical", {{}})
        if not market_regime:
            market_regime = technical.get("market_regime", "")
        if not regime_strength:
            regime_strength = technical.get("regime_strength", 0)

        if market_regime == self.blocked_regime and regime_strength >= self.min_regime_strength:
            return FilterResult(
                passed=False,
                reason=f"Regime {{self.blocked_regime}} blocked (strength: {{regime_strength:.0f}}%, win rate: {pattern.win_rate:.1f}%)",
                details={{
                    "blocked_regime": self.blocked_regime,
                    "regime_strength": regime_strength,
                    "pattern_win_rate": {pattern.win_rate:.1f}
                }}
            )

        return FilterResult(passed=True)'''

        return self.FILTER_TEMPLATE.format(
            description=proposal.filter_description,
            pattern_type=pattern.pattern_type,
            pattern_key=pattern.pattern_key,
            timestamp=datetime.now().isoformat(),
            class_name=class_name,
            filter_name=proposal.filter_name,
            win_rate=f"{pattern.win_rate:.1f}",
            total_loss=f"{pattern.total_loss:.2f}",
            priority=15,
            init_code=init_code,
            check_code=check_code
        )

    def _generate_combined_filter(self, proposal: FilterProposal) -> str:
        """Generate filter code for combined pattern."""
        pattern = proposal.pattern
        class_name = self._to_class_name(proposal.filter_name)
        details = pattern.details

        # Build condition checks
        conditions = []
        init_vars = []

        if details.get("instrument"):
            init_vars.append(f'self.blocked_instrument = "{details["instrument"]}"')
            conditions.append('instrument == self.blocked_instrument')

        if details.get("session"):
            init_vars.append(f'self.blocked_session = "{details["session"]}"')
            conditions.append('current_session == self.blocked_session')

        if details.get("direction"):
            init_vars.append(f'self.blocked_direction = "{details["direction"]}"')
            conditions.append('direction == self.blocked_direction')

        init_code = "\n        ".join(init_vars) if init_vars else "pass"
        condition_str = " and ".join(conditions) if conditions else "False"

        check_code = f'''instrument = signal_data.get("instrument", "")
        direction = signal_data.get("direction", "")

        # Determine current session
        timestamp = signal_data.get("timestamp", datetime.now())
        if hasattr(timestamp, "hour"):
            hour = timestamp.hour
        else:
            hour = datetime.now().hour

        if 7 <= hour < 16:
            current_session = "london"
        elif 12 <= hour < 21:
            current_session = "newyork"
        elif 0 <= hour < 9:
            current_session = "tokyo"
        else:
            current_session = "sydney"

        # Check combined conditions
        if {condition_str}:
            return FilterResult(
                passed=False,
                reason=f"Combined pattern blocked: {pattern.pattern_key} (win rate: {pattern.win_rate:.1f}%)",
                details={{
                    "pattern": "{pattern.pattern_key}",
                    "pattern_win_rate": {pattern.win_rate:.1f}
                }}
            )

        return FilterResult(passed=True)'''

        return self.FILTER_TEMPLATE.format(
            description=proposal.filter_description,
            pattern_type=pattern.pattern_type,
            pattern_key=pattern.pattern_key,
            timestamp=datetime.now().isoformat(),
            class_name=class_name,
            filter_name=proposal.filter_name,
            win_rate=f"{pattern.win_rate:.1f}",
            total_loss=f"{pattern.total_loss:.2f}",
            priority=10,
            init_code=init_code,
            check_code=check_code
        )

    def _build_system_prompt(self) -> str:
        """Build system prompt for Claude."""
        return """You are a Python code generator for a trading system's self-upgrade module.

Your task is to generate safe, focused filter classes that block specific trading signals
based on identified losing patterns.

IMPORTANT SAFETY RULES:
1. ONLY use these imports: dataclasses, typing, datetime, math, statistics
2. NEVER use: os, sys, subprocess, open, exec, eval, file I/O
3. NEVER access the filesystem or network
4. NEVER modify global state
5. Only inherit from BaseFilter
6. Only return FilterResult objects

The generated code must:
1. Inherit from BaseFilter (from src.upgrade.base_filter)
2. Implement the check(self, signal_data: dict) -> FilterResult method
3. Return FilterResult(passed=True) to allow a signal
4. Return FilterResult(passed=False, reason="...", details={...}) to block a signal

signal_data contains:
- instrument: str (e.g., "EUR_USD")
- direction: str ("LONG" or "SHORT")
- confidence: int (0-100)
- technical: dict (trend, rsi, macd_trend, atr_pips, market_regime, regime_strength)
- sentiment: float (-1 to 1)
- session: str (london, newyork, tokyo, sydney)
- timestamp: datetime"""

    def _build_user_prompt(self, proposal: FilterProposal) -> str:
        """Build user prompt with proposal details."""
        return f"""Generate a Python filter class based on this analysis:

{proposal.ai_prompt}

Filter name: {proposal.filter_name}
Filter description: {proposal.filter_description}

Return ONLY the Python code, no explanations. The code should be complete and runnable."""

    async def _call_llm_async(self, llm, system_prompt: str, user_prompt: str) -> Optional[str]:
        """Call LLM asynchronously."""
        try:
            # Use the existing LLM infrastructure
            response = llm._call_anthropic(
                messages=[{"role": "user", "content": user_prompt}],
                system=system_prompt,
                max_tokens=2000
            )
            return response
        except Exception as e:
            logger.error(f"LLM call failed: {e}")
            return None

    def _extract_code(self, response: str) -> Optional[str]:
        """Extract Python code from LLM response."""
        # Try to find code block
        code_match = re.search(r'```python\s*(.*?)\s*```', response, re.DOTALL)
        if code_match:
            return code_match.group(1).strip()

        # Try to find any code block
        code_match = re.search(r'```\s*(.*?)\s*```', response, re.DOTALL)
        if code_match:
            return code_match.group(1).strip()

        # Assume entire response is code if it looks like Python
        if "class " in response and "def check" in response:
            return response.strip()

        return None

    def _check_safety(self, code: str) -> List[str]:
        """Check code for safety violations."""
        violations = []

        for pattern in FORBIDDEN_PATTERNS:
            if re.search(pattern, code, re.IGNORECASE):
                violations.append(f"Forbidden pattern: {pattern}")

        # Check for any imports not in allowed list
        # Match "import X" (standalone) or "from X import" (module name only)
        # Pattern 1: "import module" or "import module.submodule"
        standalone_imports = re.findall(r'^import\s+([\w.]+)', code, re.MULTILINE)
        # Pattern 2: "from module import" - get the module name
        from_imports = re.findall(r'^from\s+([\w.]+)\s+import', code, re.MULTILINE)

        all_imports = standalone_imports + from_imports

        for imp in all_imports:
            # Get the top-level module
            top_module = imp.split(".")[0]
            if top_module not in ALLOWED_IMPORTS and top_module != "src":
                violations.append(f"Forbidden import: {imp}")

        return violations

    def _ensure_required_imports(self, code: str) -> str:
        """Ensure required imports are present."""
        required = [
            "from src.upgrade.base_filter import BaseFilter, FilterResult",
            "from datetime import datetime",
        ]

        for req in required:
            if req not in code:
                # Add at the top after any docstring
                if '"""' in code:
                    parts = code.split('"""', 2)
                    if len(parts) >= 3:
                        code = parts[0] + '"""' + parts[1] + '"""' + "\n" + req + "\n" + parts[2]
                else:
                    code = req + "\n\n" + code

        return code

    def _to_class_name(self, filter_name: str) -> str:
        """Convert filter name to class name."""
        # block_eur_usd_filter -> BlockEurUsdFilter
        words = filter_name.replace("_", " ").title().split()
        return "".join(words)


# Import datetime for template
from datetime import datetime
