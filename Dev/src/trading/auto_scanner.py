"""
Auto-Scanner - SMC-based market scanning engine for auto-trading.

Scans configured instruments using Smart Money Concepts:
1. Price → Spread → Session → News (pre-filters)
2. Candles (H4+H1+M5)
3. SMC HTF Analysis (H4/H1: structure + liquidity map)
4. HTF Bias check (NEUTRAL = NO TRADE)
5. SMC LTF Analysis (M5: sweep + CHoCH/BOS + FVG + displacement)
6. Sweep check (NO SWEEP = NO TRADE) ← HARD GATE
7. CHoCH/BOS check (NONE = NO TRADE) ← HARD GATE
8. Setup Grading (A+/A/B/NO_TRADE)
9. Grade → Confidence mapping
10. Regime filter (still useful)
11. Sentiment (additional edge)
12. Learning engine (adapts from history)
13. Filter chain (self-upgrade)
14. SL/TP (SMC-based: SL behind sweep, TP at liquidity)
15. R:R check (min 1:3)
16. Signal

Usage:
    from src.trading.auto_scanner import MarketScanner

    scanner = MarketScanner(client, config)
    signals = scanner.scan_all_instruments()
"""

import asyncio
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any

from src.trading.mt5_client import MT5Client, MT5Error
from src.core.auto_config import AutoTradingConfig, ScalpingConfig
from src.market.indicators import TechnicalAnalyzer, TechnicalAnalysis
from src.analysis.sentiment import SentimentAnalyzer, SentimentResult
from src.analysis.adversarial import AdversarialEngine
from src.analysis.confidence import ConfidenceCalculator, ConfidenceResult
from src.analysis.learning_engine import LearningEngine
from src.smc import SMCAnalyzer, SMCAnalysis
from src.smc.sequence_tracker import SequenceTracker
from src.analysis.confidence_calibrator import ConfidenceCalibrator
from src.analysis.cross_asset_detector import CrossAssetDetector
from src.utils.database import db
from src.utils.logger import logger
from src.utils.instrument_profiles import get_profile, is_in_session
from src.analysis.news_filter import news_filter
from src.upgrade.filter_registry import get_filter_registry


@dataclass
class TradingSignal:
    """A trading signal generated by the scanner."""
    instrument: str
    direction: str  # LONG or SHORT
    confidence: int
    entry_price: float
    stop_loss: float
    take_profit: float
    risk_reward: float

    # Analysis components
    technical: TechnicalAnalysis
    sentiment: SentimentResult
    confidence_result: ConfidenceResult

    # SMC Analysis
    smc_analysis: Optional[SMCAnalysis] = None

    # ISI fields
    raw_confidence: Optional[int] = None  # Pre-calibration confidence
    sequence_phase: Optional[int] = None
    sequence_phase_name: Optional[str] = None

    # Limit entry fields
    entry_zone: Optional[tuple] = None    # (low, high) of FVG/OB zone
    limit_price: Optional[float] = None   # Price for limit order
    use_limit_entry: bool = False         # Whether to use limit vs market

    # Metadata
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    scan_duration_ms: int = 0
    reason: str = ""

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        result = {
            "instrument": self.instrument,
            "direction": self.direction,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "risk_reward": self.risk_reward,
            "timestamp": self.timestamp.isoformat(),
            "scan_duration_ms": self.scan_duration_ms,
            "reason": self.reason,
            "raw_confidence": self.raw_confidence,
            "sequence_phase": self.sequence_phase,
            "sequence_phase_name": self.sequence_phase_name,
            "limit_price": self.limit_price,
            "use_limit_entry": self.use_limit_entry,
            "entry_zone": list(self.entry_zone) if self.entry_zone else None,
        }
        if self.smc_analysis:
            result["smc"] = self.smc_analysis.to_dict()
        return result


@dataclass
class ScanResult:
    """Result of scanning a single instrument."""
    instrument: str
    has_signal: bool
    signal: Optional[TradingSignal] = None
    skip_reason: Optional[str] = None
    error: Optional[str] = None
    scan_duration_ms: int = 0


class MarketScanner:
    """
    SMC-based market scanner for auto-trading.

    Scans all configured instruments using Smart Money Concepts
    and returns trading signals when high-quality setups are found.
    """

    def __init__(self, client: MT5Client, config: AutoTradingConfig):
        self.client = client
        self.config = config

        # SMC Analyzer (replaces old technical direction logic)
        self.smc_analyzer = SMCAnalyzer()

        # Keep these for supplementary analysis
        self.technical_analyzer = TechnicalAnalyzer()
        use_external = getattr(config, 'external_sentiment', None)
        use_external_sentiment = use_external.enabled if use_external else False
        self.sentiment_analyzer = SentimentAnalyzer(use_external=use_external_sentiment)
        self.adversarial_engine = AdversarialEngine()
        self.confidence_calculator = ConfidenceCalculator()
        self.learning_engine = LearningEngine()

        # ISI components
        self.sequence_tracker = SequenceTracker(db)
        self.calibrator = ConfidenceCalibrator(db)
        self.cross_asset = CrossAssetDetector(client, db)

        # Thread pool for parallel scanning
        self._executor = ThreadPoolExecutor(max_workers=4)

        # Filter registry for self-upgrade system
        self.filter_registry = get_filter_registry()
        ai_filters_loaded = self.filter_registry.load_ai_generated_filters()

        filter_status = f"{self.filter_registry.get_stats()['total_filters']} filters ({ai_filters_loaded} AI)"
        calibration_status = "fitted" if self.calibrator.is_fitted else "uncalibrated"
        logger.info(
            f"MarketScanner initialized [SMC+ISI MODE] with {len(config.instruments)} instruments "
            f"(Filters: {filter_status}, Calibration: {calibration_status})"
        )

    def scan_all_instruments(self) -> List[TradingSignal]:
        """Scan all configured instruments for SMC trading opportunities."""
        signals = []
        start_time = datetime.now(timezone.utc)

        db.log_activity({
            "activity_type": "SCAN_START",
            "reasoning": f"Starting SMC scan of {len(self.config.instruments)} instruments",
            "details": {
                "instruments": self.config.instruments,
                "mode": "SMC",
                "min_confidence": self.config.get_active_threshold(),
            }
        })

        for instrument in self.config.instruments:
            try:
                result = self.scan_instrument(instrument)
                if result.has_signal and result.signal:
                    signals.append(result.signal)
                elif result.skip_reason:
                    logger.info(f"{instrument}: Skipped - {result.skip_reason}")
                elif result.error:
                    logger.warning(f"{instrument}: Error - {result.error}")
            except Exception as e:
                logger.error(f"Failed to scan {instrument}: {e}")
                db.log_activity({
                    "activity_type": "ERROR",
                    "instrument": instrument,
                    "reasoning": f"Scan failed: {str(e)}"
                })

        duration_ms = int((datetime.now(timezone.utc) - start_time).total_seconds() * 1000)
        logger.info(f"SMC Scan complete: {len(signals)} signals from {len(self.config.instruments)} instruments in {duration_ms}ms")

        db.log_activity({
            "activity_type": "SCAN_COMPLETE",
            "reasoning": f"SMC scan complete: found {len(signals)} signals",
            "duration_ms": duration_ms,
            "details": {
                "instruments_scanned": len(self.config.instruments),
                "signals_found": len(signals),
                "signal_instruments": [s.instrument for s in signals],
            }
        })

        return signals

    async def scan_all_instruments_async(self) -> List[TradingSignal]:
        """Scan all instruments in parallel using async."""
        loop = asyncio.get_event_loop()
        tasks = [
            loop.run_in_executor(self._executor, self.scan_instrument, instrument)
            for instrument in self.config.instruments
        ]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        signals = []
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Scan error: {result}")
                continue
            if result.has_signal and result.signal:
                signals.append(result.signal)
        return signals

    def scan_instrument(self, instrument: str) -> ScanResult:
        """
        Scan a single instrument using SMC pipeline.

        Pipeline:
        Price → Spread → Session → News → Candles(H4+H1+M5)
        → SMC HTF(H4/H1) → HTF Bias → SMC LTF(M5) → Sweep → CHoCH/BOS
        → Grading → Confidence → Regime → Sentiment → Learning → Filters
        → SL/TP → R:R → Signal
        """
        start_time = datetime.now(timezone.utc)

        db.log_activity({
            "activity_type": "ANALYZING",
            "instrument": instrument,
            "reasoning": f"Starting SMC analysis of {instrument}..."
        })

        try:
            # ==========================================
            # STEP 1: Pre-filters (quick rejections)
            # ==========================================

            # 1a. Get current price
            price = self.client.get_price(instrument)

            # 1b. Check spread
            if not self._check_spread(price, instrument):
                return self._skip(instrument, start_time,
                                  f"Spread too high: {price['spread_pips']:.1f} pips",
                                  {"spread_pips": price.get("spread_pips")})

            # 1c. Check trading session
            profile = get_profile(instrument)
            if not is_in_session(profile):
                return self._skip(instrument, start_time,
                                  f"Outside trading session (allowed: {profile.get('sessions', [])})")

            # 1d. Check news calendar
            should_avoid, news_reason = news_filter.should_avoid_trade(instrument)
            if should_avoid:
                return self._skip(instrument, start_time,
                                  f"News filter: {news_reason}")

            # ==========================================
            # STEP 2: Fetch candle data (H4, H1, M5)
            # ==========================================

            # H4 candles for HTF structure
            h4_candles = self.client.get_candles(instrument, "H4", 100)

            # H1 candles for liquidity map + session levels
            h1_candles = self.client.get_candles(instrument, "H1", 100)

            # M5 candles for LTF signal
            m5_candles = self.client.get_candles(instrument, "M5", 100)

            if len(m5_candles) < 30:
                return self._skip(instrument, start_time,
                                  f"Not enough M5 data ({len(m5_candles)} candles)")

            # ==========================================
            # STEP 3: SMC HTF Analysis (H4/H1)
            # ==========================================

            htf_result = self.smc_analyzer.analyze_htf(h4_candles, h1_candles, instrument)

            # HARD GATE: HTF must not be neutral
            if htf_result["htf_bias"] == "NEUTRAL":
                return self._skip(instrument, start_time,
                                  f"HTF bias NEUTRAL (structure: {htf_result['htf_structure']})",
                                  {"htf_structure": htf_result["htf_structure"]})

            # ==========================================
            # STEP 4: SMC LTF Analysis (M5)
            # ==========================================

            smc_analysis = self.smc_analyzer.analyze_ltf(m5_candles, htf_result, instrument)

            # HARD GATE: Must have sweep
            if not smc_analysis.sweep_detected:
                return self._skip(instrument, start_time,
                                  "No liquidity sweep detected",
                                  {"htf_bias": htf_result["htf_bias"]})

            # HARD GATE: Must have CHoCH or BOS
            if not smc_analysis.ltf_choch and not smc_analysis.ltf_bos:
                return self._skip(instrument, start_time,
                                  "No CHoCH or BOS on LTF",
                                  {"sweep": smc_analysis.sweep_detected.to_dict()})

            # HARD GATE: Must have direction
            if not smc_analysis.direction:
                return self._skip(instrument, start_time,
                                  "No clear SMC direction",
                                  {"htf_bias": htf_result["htf_bias"],
                                   "grade_reasons": smc_analysis.grade_reasons})

            # HARD GATE: Setup grade must be B or better
            if smc_analysis.setup_grade == "NO_TRADE":
                return self._skip(instrument, start_time,
                                  f"Setup grade: NO_TRADE ({', '.join(smc_analysis.grade_reasons[:3])})")

            direction = smc_analysis.direction

            # ==========================================
            # STEP 4.5: ISI Sequence Tracking
            # ==========================================

            # Still run technical first for sequence tracker input
            technical = self.technical_analyzer.analyze(m5_candles, instrument)

            seq_state = self.sequence_tracker.update(instrument, smc_analysis, technical)
            seq_modifier = seq_state.confidence_modifier()

            db.log_activity({
                "activity_type": "SEQUENCE_UPDATE",
                "instrument": instrument,
                "details": {
                    "phase": seq_state.current_phase,
                    "phase_name": seq_state.phase_name,
                    "phase_confidence": seq_state.phase_confidence,
                    "confidence_modifier": seq_modifier,
                    "completion_rate": seq_state.completion_rate,
                }
            })

            # ==========================================
            # STEP 5: Market Regime filter (technical already computed above)
            # ==========================================

            # 5a. Market Regime filter (still useful)
            regime_ok, regime_reason = self._check_market_regime(technical, instrument)
            if not regime_ok:
                return self._skip(instrument, start_time,
                                  f"Regime filter: {regime_reason}",
                                  {"market_regime": technical.market_regime,
                                   "smc_grade": smc_analysis.setup_grade})

            # ==========================================
            # STEP 6: Sentiment (additional edge)
            # ==========================================

            sentiment = self.sentiment_analyzer.analyze(m5_candles, technical, instrument=instrument)

            # ==========================================
            # STEP 6.5: ISI Cross-Asset Divergence
            # ==========================================

            divergence_modifier = self.cross_asset.get_confidence_modifier(instrument, direction)

            # ==========================================
            # STEP 7: Calculate confidence (SMC + ISI)
            # ==========================================

            # SMC grade is primary driver, plus ISI modifiers
            smc_confidence = smc_analysis.confidence  # From grade: A+=92, A=82, B=68

            # Sentiment adjustment (-10 to +10)
            sent_score = sentiment.sentiment_score  # -1 to +1
            sent_adjustment = int(sent_score * 10)  # -10 to +10
            # Align with direction
            if direction == "SHORT":
                sent_adjustment = -sent_adjustment

            # ISI: sequence + divergence modifiers
            base_confidence = smc_confidence + sent_adjustment + seq_modifier + divergence_modifier

            # Build confidence result for compatibility
            adversarial = self.adversarial_engine.analyze(
                technical, sentiment, instrument, direction
            )
            confidence_result = self.confidence_calculator.calculate(
                technical, sentiment, adversarial, 0
            )
            # Override with SMC+ISI-based confidence
            raw_score = max(0, min(100, base_confidence))

            # ISI: Bayesian calibration (Platt Scaling)
            calibrated_score = self.calibrator.calibrate(raw_score)
            confidence_result.confidence_score = calibrated_score

            # Generate SMC-based bull/bear case
            confidence_result.bull_case = self._build_smc_bull_case(smc_analysis)
            confidence_result.bear_case = self._build_smc_bear_case(smc_analysis)

            # ==========================================
            # STEP 8: Learning engine adjustment
            # ==========================================

            learning_context = {
                "session": technical.session if hasattr(technical, 'session') else None,
                "trend": technical.trend,
                "market_regime": technical.market_regime,
                "regime_strength": technical.regime_strength,
                "smc_grade": smc_analysis.setup_grade,
            }
            learning_insights = self.learning_engine.get_insights_for_trade(
                instrument, direction, learning_context
            )

            original_confidence = confidence_result.confidence_score
            adjusted_confidence = max(0, min(100,
                original_confidence + learning_insights.confidence_adjustment
            ))
            confidence_result.confidence_score = adjusted_confidence

            # Killzone boost
            in_killzone, killzone_name = self._is_in_killzone()
            if in_killzone:
                adjusted_confidence = min(100, adjusted_confidence + 5)
                confidence_result.confidence_score = adjusted_confidence

            # Check if learning blocks trade
            if not learning_insights.should_trade:
                return self._skip(instrument, start_time,
                                  f"Learning blocked: {', '.join(learning_insights.warnings[:2])}",
                                  {"smc_grade": smc_analysis.setup_grade})

            # ==========================================
            # STEP 9: Confidence threshold check
            # ==========================================

            active_threshold = self.config.get_active_threshold()
            instrument_threshold = profile.get("min_confidence_threshold")
            if instrument_threshold is not None:
                active_threshold = min(active_threshold, instrument_threshold)

            if confidence_result.confidence_score < active_threshold:
                return self._skip(instrument, start_time,
                                  f"Confidence {confidence_result.confidence_score}% < {active_threshold}%",
                                  {"smc_grade": smc_analysis.setup_grade,
                                   "confidence": confidence_result.confidence_score})

            # ==========================================
            # STEP 10: Filter chain (self-upgrade system)
            # ==========================================

            filter_result = self._run_filter_chain(
                instrument, direction,
                confidence_result.confidence_score,
                technical, sentiment
            )
            if not filter_result.passed:
                return self._skip(instrument, start_time,
                                  f"Filter: {filter_result.reason}",
                                  {"blocking_filter": filter_result.blocking_filter})

            # ==========================================
            # STEP 11: SL/TP from SMC analysis
            # ==========================================

            entry_price = price["ask"] if direction == "LONG" else price["bid"]

            # Use SMC-calculated SL/TP
            if smc_analysis.stop_loss and smc_analysis.take_profit:
                sl = smc_analysis.stop_loss
                tp = smc_analysis.take_profit
            else:
                # Fallback to ATR-based
                sl, tp = self._calculate_sl_tp_fallback(
                    entry_price, direction, technical, instrument
                )

            # ==========================================
            # STEP 12: R:R check (min 1:3)
            # ==========================================

            risk = abs(entry_price - sl)
            reward = abs(tp - entry_price)
            risk_reward = reward / risk if risk > 0 else 0

            effective_target_rr = profile.get("target_rr", self.config.scalping.target_rr)
            if risk_reward < effective_target_rr - 0.01:
                return self._skip(instrument, start_time,
                                  f"R:R {risk_reward:.2f} < {effective_target_rr}",
                                  {"risk_reward": risk_reward,
                                   "smc_grade": smc_analysis.setup_grade})

            # ==========================================
            # STEP 13: Create signal
            # ==========================================

            signal = TradingSignal(
                instrument=instrument,
                direction=direction,
                confidence=confidence_result.confidence_score,
                entry_price=entry_price,
                stop_loss=sl,
                take_profit=tp,
                risk_reward=risk_reward,
                technical=technical,
                sentiment=sentiment,
                confidence_result=confidence_result,
                smc_analysis=smc_analysis,
                raw_confidence=raw_score,
                sequence_phase=seq_state.current_phase,
                sequence_phase_name=seq_state.phase_name,
                scan_duration_ms=self._get_duration_ms(start_time),
                reason=(
                    f"SMC {smc_analysis.setup_grade} {direction} "
                    f"P{seq_state.current_phase}({seq_state.phase_name}): "
                    f"sweep={'YES' if smc_analysis.sweep_detected else 'NO'}, "
                    f"choch={'YES' if smc_analysis.ltf_choch else 'NO'}, "
                    f"bos={'YES' if smc_analysis.ltf_bos else 'NO'}"
                ),
            )

            # ==========================================
            # STEP 13.5: Limit entry calculation
            # ==========================================

            if (self.config.limit_entry.enabled and
                    smc_analysis.entry_zone is not None):
                zone_low, zone_high = smc_analysis.entry_zone
                # Per-instrument midpoint override (e.g. XAU_USD uses edge, not midpoint)
                use_midpoint = profile.get("limit_entry_midpoint", self.config.limit_entry.midpoint_entry)
                if use_midpoint:
                    limit_price = (zone_low + zone_high) / 2
                else:
                    # Edge entry: top of zone for LONG, bottom for SHORT
                    limit_price = zone_high if direction == "LONG" else zone_low

                signal.entry_zone = smc_analysis.entry_zone
                signal.limit_price = limit_price
                signal.use_limit_entry = True
                signal.entry_price = limit_price  # Update for R:R recalc

                # Recalculate R:R with limit price
                risk = abs(limit_price - sl)
                reward = abs(tp - limit_price)
                new_rr = reward / risk if risk > 0 else 0
                signal.risk_reward = new_rr

                logger.info(
                    f"LIMIT ENTRY: {instrument} {direction} "
                    f"limit={limit_price:.5f} zone=({zone_low:.5f},{zone_high:.5f}) "
                    f"R:R={new_rr:.2f} (was {risk_reward:.2f})"
                )

            logger.info(
                f"SIGNAL: {instrument} {direction} "
                f"grade={smc_analysis.setup_grade} "
                f"conf={confidence_result.confidence_score}% "
                f"R:R={signal.risk_reward:.2f}"
                f"{' [LIMIT]' if signal.use_limit_entry else ''}"
            )

            # Log signal
            db.log_activity({
                "activity_type": "SIGNAL_GENERATED",
                "instrument": instrument,
                "direction": direction,
                "confidence": confidence_result.confidence_score,
                "decision": "SIGNAL",
                "reasoning": signal.reason,
                "details": {
                    "smc_grade": smc_analysis.setup_grade,
                    "htf_bias": smc_analysis.htf_bias,
                    "sweep_type": smc_analysis.sweep_detected.sweep_direction if smc_analysis.sweep_detected else None,
                    "choch": smc_analysis.ltf_choch.direction if smc_analysis.ltf_choch else None,
                    "bos": smc_analysis.ltf_bos.direction if smc_analysis.ltf_bos else None,
                    "displacement": smc_analysis.ltf_displacement is not None,
                    "fvg_count": len(smc_analysis.fvgs),
                    "ob_count": len(smc_analysis.order_blocks),
                    "premium_discount": smc_analysis.premium_discount.get("zone") if smc_analysis.premium_discount else None,
                    "entry_price": entry_price,
                    "stop_loss": sl,
                    "take_profit": tp,
                    "risk_reward": risk_reward,
                    "grade_reasons": smc_analysis.grade_reasons,
                    "bull_case": confidence_result.bull_case,
                    "bear_case": confidence_result.bear_case,
                    # ISI data
                    "raw_confidence": raw_score,
                    "calibrated_confidence": calibrated_score,
                    "sequence_phase": seq_state.current_phase,
                    "sequence_phase_name": seq_state.phase_name,
                    "seq_modifier": seq_modifier,
                    "divergence_modifier": divergence_modifier,
                    "heat_map": smc_analysis.heat_map.to_dict() if smc_analysis.heat_map else None,
                    "use_limit_entry": signal.use_limit_entry,
                    "limit_price": signal.limit_price,
                    "entry_zone": list(signal.entry_zone) if signal.entry_zone else None,
                },
                "duration_ms": self._get_duration_ms(start_time),
            })

            # Save to auto_signals table
            db.log_auto_signal({
                "timestamp": signal.timestamp.isoformat(),
                "instrument": instrument,
                "direction": direction,
                "confidence": confidence_result.confidence_score,
                "entry_price": entry_price,
                "stop_loss": sl,
                "take_profit": tp,
                "risk_reward": risk_reward,
                "executed": 0,
                "skip_reason": None,
                "trade_id": None,
            })

            return ScanResult(
                instrument=instrument,
                has_signal=True,
                signal=signal,
                scan_duration_ms=self._get_duration_ms(start_time),
            )

        except MT5Error as e:
            db.log_activity({
                "activity_type": "ERROR",
                "instrument": instrument,
                "reasoning": f"MT5 error: {str(e)}"
            })
            return ScanResult(
                instrument=instrument,
                has_signal=False,
                error=f"MT5 error: {e}",
                scan_duration_ms=self._get_duration_ms(start_time),
            )
        except Exception as e:
            logger.exception(f"Scan error for {instrument}")
            db.log_activity({
                "activity_type": "ERROR",
                "instrument": instrument,
                "reasoning": f"Scan error: {str(e)}"
            })
            return ScanResult(
                instrument=instrument,
                has_signal=False,
                error=str(e),
                scan_duration_ms=self._get_duration_ms(start_time),
            )

    # ==========================================
    # Helper methods
    # ==========================================

    def _skip(
        self,
        instrument: str,
        start_time: datetime,
        reason: str,
        details: dict = None
    ) -> ScanResult:
        """Create a skip result with logging."""
        db.log_activity({
            "activity_type": "SIGNAL_REJECTED",
            "instrument": instrument,
            "decision": "SKIP",
            "reasoning": reason,
            "details": details or {},
        })
        return ScanResult(
            instrument=instrument,
            has_signal=False,
            skip_reason=reason,
            scan_duration_ms=self._get_duration_ms(start_time),
        )

    def _check_spread(self, price: dict, instrument: str) -> bool:
        """Check if spread is acceptable."""
        profile = get_profile(instrument)
        max_spread = profile.get("max_spread_pips", self.config.scalping.max_spread_pips)
        return price.get("spread_pips", 999) <= max_spread

    def _check_market_regime(
        self,
        technical: TechnicalAnalysis,
        instrument: str
    ) -> tuple:
        """Check if market regime is suitable."""
        regime = technical.market_regime
        strength = technical.regime_strength

        profile = get_profile(instrument)
        if profile.get("skip_regime_filter", False):
            return True, "OK (regime filter skipped)"

        if regime == "LOW_VOLATILITY" and strength >= 60:
            return False, f"Low volatility (ADX={technical.adx:.1f})"

        if regime == "VOLATILE" and strength >= 65:
            return False, f"High volatility ({technical.bollinger_width_percentile:.0f}th pct)"

        return True, "OK"

    def _is_in_killzone(self) -> tuple:
        """Check if current time is in a high-probability killzone."""
        hour = datetime.now(timezone.utc).hour
        if 7 <= hour < 9:
            return True, "LONDON_OPEN"
        if 12 <= hour < 14:
            return True, "NY_OPEN"
        if 15 <= hour < 17:
            return True, "LONDON_CLOSE"
        return False, ""

    def _calculate_sl_tp_fallback(
        self,
        entry: float,
        direction: str,
        technical: TechnicalAnalysis,
        instrument: str
    ) -> tuple:
        """Fallback SL/TP using ATR when SMC zones unavailable."""
        profile = get_profile(instrument)
        max_sl = profile.get("max_sl_pips", self.config.scalping.max_sl_pips)
        target_rr = profile.get("target_rr", self.config.scalping.target_rr)

        if "XAU" in instrument:
            pip_value = 0.1
        elif "BTC" in instrument or "ETH" in instrument:
            pip_value = 1.0
        elif "JPY" in instrument:
            pip_value = 0.01
        else:
            pip_value = 0.0001

        sl_pips = min(technical.atr_pips * 1.5, max_sl)
        tp_pips = sl_pips * target_rr

        if direction == "LONG":
            sl = entry - (sl_pips * pip_value)
            tp = entry + (tp_pips * pip_value)
        else:
            sl = entry + (sl_pips * pip_value)
            tp = entry - (tp_pips * pip_value)

        return sl, tp

    def _build_smc_bull_case(self, smc: SMCAnalysis) -> str:
        """Build bull case from SMC analysis."""
        points = []
        if smc.htf_bias == "BULLISH":
            points.append(f"HTF bullish ({smc.htf_structure})")
        if smc.sweep_detected:
            s = smc.sweep_detected
            points.append(f"{s.sweep_direction} at {s.level.price:.5f}")
        if smc.ltf_choch and smc.ltf_choch.direction == "BULLISH":
            points.append(f"Bullish CHoCH at {smc.ltf_choch.break_level:.5f}")
        if smc.ltf_bos and smc.ltf_bos.direction == "BULLISH":
            points.append(f"Bullish BOS at {smc.ltf_bos.break_level:.5f}")
        if smc.ltf_displacement and smc.ltf_displacement.direction == "BULLISH":
            points.append(f"Bullish displacement ({smc.ltf_displacement.avg_body_ratio:.1f}x)")
        unfilled_fvgs = [f for f in smc.fvgs if not f.filled and f.direction == "BULLISH"]
        if unfilled_fvgs:
            points.append(f"{len(unfilled_fvgs)} unfilled bullish FVG(s)")
        pd = smc.premium_discount
        if pd and pd.get("zone") == "DISCOUNT":
            points.append(f"Price in discount zone ({pd.get('percentage', 0):.0f}%)")
        return "; ".join(points) if points else "No strong bullish factors"

    def _build_smc_bear_case(self, smc: SMCAnalysis) -> str:
        """Build bear case from SMC analysis."""
        points = []
        if smc.htf_bias == "BEARISH":
            points.append(f"HTF bearish ({smc.htf_structure})")
        if smc.htf_bias == "NEUTRAL":
            points.append("HTF neutral (no clear bias)")
        if not smc.ltf_displacement:
            points.append("No displacement confirmation")
        pd = smc.premium_discount
        if pd and pd.get("zone") == "EQUILIBRIUM":
            points.append(f"Price in equilibrium ({pd.get('percentage', 0):.0f}%)")
        unfilled_fvgs = [f for f in smc.fvgs if not f.filled]
        if not unfilled_fvgs:
            points.append("No unfilled FVGs")
        fresh_obs = [ob for ob in smc.order_blocks if not ob.mitigated]
        if not fresh_obs:
            points.append("No fresh order blocks")
        return "; ".join(points) if points else "No significant bearish factors"

    def _run_filter_chain(
        self,
        instrument: str,
        direction: str,
        confidence: int,
        technical: TechnicalAnalysis,
        sentiment: SentimentResult
    ):
        """Run the filter chain from the Self-Upgrade System."""
        signal_data = {
            "instrument": instrument,
            "direction": direction,
            "confidence": confidence,
            "technical": {
                "trend": technical.trend,
                "trend_strength": getattr(technical, "trend_strength", 0),
                "rsi": technical.rsi,
                "macd_trend": technical.macd_trend,
                "atr_pips": technical.atr_pips,
                "market_regime": technical.market_regime,
                "regime_strength": technical.regime_strength,
                "adx": technical.adx,
            },
            "market_regime": technical.market_regime,
            "regime_strength": technical.regime_strength,
            "sentiment": sentiment.sentiment_score,
            "timestamp": datetime.now(timezone.utc),
        }

        hour = datetime.now(timezone.utc).hour
        if 7 <= hour < 16:
            signal_data["session"] = "london"
        elif 12 <= hour < 21:
            signal_data["session"] = "newyork"
        elif 0 <= hour < 9:
            signal_data["session"] = "tokyo"
        else:
            signal_data["session"] = "sydney"

        return self.filter_registry.run_all_filters(signal_data)

    def _get_duration_ms(self, start_time: datetime) -> int:
        return int((datetime.now(timezone.utc) - start_time).total_seconds() * 1000)

    def get_scan_summary(self) -> dict:
        """Get summary of scanner configuration."""
        return {
            "instruments": self.config.instruments,
            "mode": "SMC",
            "min_confidence": self.config.min_confidence_threshold,
            "scan_interval": self.config.scan_interval_seconds,
            "scalping_config": {
                "max_sl_pips": self.config.scalping.max_sl_pips,
                "target_rr": self.config.scalping.target_rr,
                "max_spread_pips": self.config.scalping.max_spread_pips,
            }
        }
