"""
Auto-Scanner - Market scanning engine for auto-trading.

Continuously scans configured instruments for trading opportunities.
Uses existing analysis components (Technical, Sentiment, Confidence).

Usage:
    from src.trading.auto_scanner import MarketScanner

    scanner = MarketScanner(client, config)
    signals = scanner.scan_all_instruments()
"""

import asyncio
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any

from src.trading.mt5_client import MT5Client, MT5Error
from src.core.auto_config import AutoTradingConfig, ScalpingConfig
from src.market.indicators import TechnicalAnalyzer, TechnicalAnalysis
from src.analysis.sentiment import SentimentAnalyzer, SentimentResult
from src.analysis.adversarial import AdversarialEngine
from src.analysis.confidence import ConfidenceCalculator, ConfidenceResult
from src.analysis.learning_engine import LearningEngine
from src.analysis.ai_override import AIOverrideEvaluator, AIOverrideConfig, OverrideContext
from src.core.tuning_config import TunableSettings
from src.utils.database import db
from src.utils.logger import logger
from src.utils.instrument_profiles import get_profile, is_in_session
from src.analysis.news_filter import news_filter
from src.upgrade.filter_registry import get_filter_registry


@dataclass
class TradingSignal:
    """A trading signal generated by the scanner."""
    instrument: str
    direction: str  # LONG or SHORT
    confidence: int
    entry_price: float
    stop_loss: float
    take_profit: float
    risk_reward: float

    # Analysis components
    technical: TechnicalAnalysis
    sentiment: SentimentResult
    confidence_result: ConfidenceResult

    # Metadata
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    scan_duration_ms: int = 0
    reason: str = ""

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "instrument": self.instrument,
            "direction": self.direction,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "risk_reward": self.risk_reward,
            "timestamp": self.timestamp.isoformat(),
            "scan_duration_ms": self.scan_duration_ms,
            "reason": self.reason
        }


@dataclass
class ScanResult:
    """Result of scanning a single instrument."""
    instrument: str
    has_signal: bool
    signal: Optional[TradingSignal] = None
    skip_reason: Optional[str] = None
    error: Optional[str] = None
    scan_duration_ms: int = 0


class MarketScanner:
    """
    Market scanner for auto-trading.

    Scans all configured instruments and returns trading signals
    when opportunities are found.
    """

    def __init__(self, client: MT5Client, config: AutoTradingConfig):
        """
        Initialize scanner.

        Args:
            client: MT5 client for market data
            config: Auto-trading configuration
        """
        self.client = client
        self.config = config

        # Analysis components
        self.technical_analyzer = TechnicalAnalyzer()
        # Use external sentiment if enabled in config (Phase 2 Enhancement)
        use_external = getattr(config, 'external_sentiment', None)
        use_external_sentiment = use_external.enabled if use_external else False
        self.sentiment_analyzer = SentimentAnalyzer(use_external=use_external_sentiment)
        self.adversarial_engine = AdversarialEngine()
        self.confidence_calculator = ConfidenceCalculator()
        self.learning_engine = LearningEngine()

        # AI Override evaluator
        override_config = AIOverrideConfig(
            enabled=config.ai_override.enabled,
            min_ai_confidence=config.ai_override.min_ai_confidence,
            max_overrides_per_day=config.ai_override.max_overrides_per_day,
            cooldown_after_loss_minutes=config.ai_override.cooldown_after_loss_minutes,
            adjustable_settings=config.ai_override.adjustable_settings,
            learning=config.ai_override.learning,
        )
        self.override_evaluator = AIOverrideEvaluator(override_config)

        # Thread pool for parallel scanning
        self._executor = ThreadPoolExecutor(max_workers=4)

        # Filter registry for self-upgrade system
        self.filter_registry = get_filter_registry()
        # Load any AI-generated filters
        ai_filters_loaded = self.filter_registry.load_ai_generated_filters()

        override_status = "ENABLED" if config.ai_override.enabled else "DISABLED"
        filter_status = f"{self.filter_registry.get_stats()['total_filters']} filters ({ai_filters_loaded} AI)"
        logger.info(f"MarketScanner initialized with {len(config.instruments)} instruments (Learning Engine ACTIVE, AI Override {override_status}, Filters: {filter_status})")

    def scan_all_instruments(self) -> List[TradingSignal]:
        """
        Scan all configured instruments for trading opportunities.

        Returns:
            List of trading signals (only valid opportunities)
        """
        signals = []
        start_time = datetime.now(timezone.utc)

        # Log scan start with learning mode info
        learning_info = {
            "learning_mode": self.config.learning_mode.is_in_learning(),
            "learning_progress": f"{self.config.learning_mode.current_trades}/{self.config.learning_mode.target_trades}",
            "active_threshold": self.config.get_active_threshold()
        }
        db.log_activity({
            "activity_type": "SCAN_START",
            "reasoning": f"Starting scan of {len(self.config.instruments)} instruments",
            "details": {
                "instruments": self.config.instruments,
                "mode": self.config.mode,
                "min_confidence": self.config.get_active_threshold(),
                **learning_info
            }
        })

        for instrument in self.config.instruments:
            try:
                result = self.scan_instrument(instrument)
                if result.has_signal and result.signal:
                    signals.append(result.signal)
                elif result.skip_reason:
                    logger.info(f"{instrument}: Skipped - {result.skip_reason}")
                elif result.error:
                    logger.warning(f"{instrument}: Error - {result.error}")
            except Exception as e:
                logger.error(f"Failed to scan {instrument}: {e}")
                db.log_activity({
                    "activity_type": "ERROR",
                    "instrument": instrument,
                    "reasoning": f"Scan failed: {str(e)}"
                })

        duration_ms = int((datetime.now(timezone.utc) - start_time).total_seconds() * 1000)
        logger.info(f"Scan complete: {len(signals)} signals from {len(self.config.instruments)} instruments in {duration_ms}ms")

        # Log scan complete
        db.log_activity({
            "activity_type": "SCAN_COMPLETE",
            "reasoning": f"Scan complete: found {len(signals)} signals",
            "duration_ms": duration_ms,
            "details": {
                "instruments_scanned": len(self.config.instruments),
                "signals_found": len(signals),
                "signal_instruments": [s.instrument for s in signals]
            }
        })

        return signals

    async def scan_all_instruments_async(self) -> List[TradingSignal]:
        """
        Scan all instruments in parallel using async.

        Returns:
            List of trading signals
        """
        loop = asyncio.get_event_loop()

        # Run scans in thread pool
        tasks = [
            loop.run_in_executor(self._executor, self.scan_instrument, instrument)
            for instrument in self.config.instruments
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        signals = []
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Scan error: {result}")
                continue
            if result.has_signal and result.signal:
                signals.append(result.signal)

        return signals

    def scan_instrument(self, instrument: str) -> ScanResult:
        """
        Scan a single instrument for trading opportunity.

        Args:
            instrument: Instrument symbol (e.g., "EURUSD")

        Returns:
            ScanResult with signal if opportunity found
        """
        start_time = datetime.now(timezone.utc)

        # Log start of analysis for this instrument
        db.log_activity({
            "activity_type": "ANALYZING",
            "instrument": instrument,
            "reasoning": f"Starting analysis of {instrument}..."
        })

        try:
            # 1. Get current price
            price = self.client.get_price(instrument)

            # 2. Check spread
            if not self._check_spread(price, instrument):
                skip_reason = f"Spread too high: {price['spread_pips']:.1f} pips"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "decision": "SKIP",
                    "reasoning": skip_reason,
                    "details": {"spread_pips": price.get("spread_pips"), "max_spread": self.config.scalping.max_spread_pips}
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 2.5 Check trading session EARLY (before heavy analysis)
            profile = get_profile(instrument)
            if not is_in_session(profile):
                allowed_sessions = profile.get("sessions", [])
                skip_reason = f"Outside trading session (allowed: {allowed_sessions})"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "decision": "SKIP",
                    "reasoning": skip_reason,
                    "details": {"sessions": allowed_sessions, "allow_weekends": profile.get("allow_weekends", False)}
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 2.6 Check news calendar (avoid high-impact events)
            should_avoid, news_reason = news_filter.should_avoid_trade(instrument)
            if should_avoid:
                skip_reason = f"News filter: {news_reason}"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "decision": "SKIP",
                    "reasoning": skip_reason,
                    "details": {"news_event": news_reason}
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 3. Get candles for analysis (M5 for scalping, H1 otherwise)
            timeframe = "M5" if self.config.mode == "scalping" else "H1"
            candles = self.client.get_candles(instrument, timeframe, 100)
            if len(candles) < 30:
                skip_reason = "Not enough candle data"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "decision": "SKIP",
                    "reasoning": skip_reason,
                    "details": {"candles_available": len(candles), "required": 30}
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 4. Technical analysis (primary timeframe)
            technical = self.technical_analyzer.analyze(candles, instrument)

            # 4.1 Market Regime Filter (Phase 1 Enhancement)
            regime_ok, regime_reason = self._check_market_regime(technical, instrument)
            if not regime_ok:
                skip_reason = f"Regime filter: {regime_reason}"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "decision": "SKIP",
                    "reasoning": skip_reason,
                    "details": {
                        "market_regime": technical.market_regime,
                        "regime_strength": technical.regime_strength,
                        "adx": technical.adx,
                        "bb_width": technical.bollinger_width,
                        "bb_percentile": technical.bollinger_width_percentile
                    }
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 4.5 Multi-Timeframe Analysis for scalping mode
            htf_technical = None
            if self.config.mode == "scalping":
                candles_h1 = self.client.get_candles(instrument, "H1", 50)
                if len(candles_h1) >= 20:
                    htf_technical = self.technical_analyzer.analyze(candles_h1, instrument)

                    # Check MTF alignment
                    mtf_ok, mtf_reason = self._confirm_mtf_trend(technical, htf_technical)
                    if not mtf_ok:
                        skip_reason = f"MTF conflict: {mtf_reason}"

                        # Determine direction for override evaluation
                        prelim_direction = None
                        if technical.trend == "BULLISH" or technical.macd_trend == "BULLISH":
                            prelim_direction = "LONG"
                        elif technical.trend == "BEARISH" or technical.macd_trend == "BEARISH":
                            prelim_direction = "SHORT"

                        # Try AI Override for MTF conflict
                        if prelim_direction:
                            prelim_sentiment = self.sentiment_analyzer.analyze(candles, technical, instrument=instrument)
                            override_result = self._evaluate_override(
                                instrument=instrument,
                                direction=prelim_direction,
                                skip_reason=skip_reason,
                                confidence=50,  # Preliminary confidence
                                technical=technical,
                                sentiment=prelim_sentiment,
                                price=price,
                                htf_technical=htf_technical
                            )

                            if override_result:
                                # AI approved override - continue with signal generation
                                logger.info(f"AI_OVERRIDE_APPLIED | {instrument} | Continuing despite MTF conflict")
                                # Don't return - continue processing
                            else:
                                db.log_activity({
                                    "activity_type": "SIGNAL_REJECTED",
                                    "instrument": instrument,
                                    "decision": "SKIP",
                                    "reasoning": skip_reason,
                                    "details": {
                                        "m5_trend": technical.trend,
                                        "h1_trend": htf_technical.trend,
                                        "m5_macd": technical.macd_trend,
                                        "h1_macd": htf_technical.macd_trend,
                                        "override_attempted": True,
                                        "override_result": "REJECTED"
                                    }
                                })
                                return ScanResult(
                                    instrument=instrument,
                                    has_signal=False,
                                    skip_reason=skip_reason,
                                    scan_duration_ms=self._get_duration_ms(start_time)
                                )
                        else:
                            db.log_activity({
                                "activity_type": "SIGNAL_REJECTED",
                                "instrument": instrument,
                                "decision": "SKIP",
                                "reasoning": skip_reason,
                                "details": {
                                    "m5_trend": technical.trend,
                                    "h1_trend": htf_technical.trend,
                                    "m5_macd": technical.macd_trend,
                                    "h1_macd": htf_technical.macd_trend
                                }
                            })
                            return ScanResult(
                                instrument=instrument,
                                has_signal=False,
                                skip_reason=skip_reason,
                                scan_duration_ms=self._get_duration_ms(start_time)
                            )

            # 5. Sentiment analysis (with external sources if enabled)
            sentiment = self.sentiment_analyzer.analyze(candles, technical, instrument=instrument)

            # 6. Determine direction
            direction = self._determine_direction(technical, sentiment)
            if not direction:
                skip_reason = "No clear direction"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "technical_score": technical.trend_strength if hasattr(technical, 'trend_strength') else None,
                    "sentiment_score": sentiment.sentiment_score,
                    "decision": "SKIP",
                    "reasoning": f"{skip_reason} - Trend: {technical.trend}, RSI: {technical.rsi:.1f}, MACD: {technical.macd_trend}",
                    "details": {
                        "trend": technical.trend,
                        "rsi": technical.rsi,
                        "macd_trend": technical.macd_trend,
                        "sentiment": sentiment.sentiment_score
                    }
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 7. Adversarial analysis
            adversarial = self.adversarial_engine.analyze(
                technical, sentiment, instrument, direction
            )

            # 8. Check RAG for similar errors
            similar_errors = db.find_similar_errors(instrument, limit=3)
            rag_warnings = len(similar_errors)

            # 9. Calculate confidence
            confidence_result = self.confidence_calculator.calculate(
                technical, sentiment, adversarial, rag_warnings
            )

            # 9.5. Apply learning from past trades
            learning_context = {
                "session": technical.session if hasattr(technical, 'session') else None,
                "trend": technical.trend,
                "rsi": technical.rsi,
                # Phase 4 Enhancement: Include market regime for regime-aware learning
                "market_regime": technical.market_regime,
                "regime_strength": technical.regime_strength,
            }
            learning_insights = self.learning_engine.get_insights_for_trade(
                instrument, direction, learning_context
            )

            # Adjust confidence based on learning
            original_confidence = confidence_result.confidence_score
            adjusted_confidence = max(0, min(100,
                original_confidence + learning_insights.confidence_adjustment
            ))
            confidence_result.confidence_score = adjusted_confidence

            # 9.55 Apply killzone boost (high-probability trading windows)
            in_killzone, killzone_name = self._is_in_killzone()
            killzone_boost = 0
            if in_killzone:
                killzone_boost = 5  # +5% confidence during killzones
                adjusted_confidence = min(100, adjusted_confidence + killzone_boost)
                confidence_result.confidence_score = adjusted_confidence
                logger.info(f"Killzone boost: {killzone_name} +{killzone_boost}% -> {adjusted_confidence}%")

            # Log learning application
            if learning_insights.confidence_adjustment != 0 or killzone_boost != 0:
                logger.info(
                    f"Confidence adjustments: Learning={learning_insights.confidence_adjustment:+d}, "
                    f"Killzone={killzone_boost:+d} -> {adjusted_confidence}%"
                )

            # Log analysis
            db.log_activity({
                "activity_type": "ANALYZING",
                "instrument": instrument,
                "direction": direction,
                "technical_score": confidence_result.technical_score,
                "sentiment_score": sentiment.sentiment_score,
                "adversarial_score": adversarial.risk_score if hasattr(adversarial, 'risk_score') else None,
                "confidence": confidence_result.confidence_score,
                "reasoning": f"Analysis: Tech={confidence_result.technical_score}, Sent={sentiment.sentiment_score:.2f}, Conf={confidence_result.confidence_score}%",
                "details": {
                    "trend": technical.trend,
                    "rsi": technical.rsi,
                    "macd_trend": technical.macd_trend,
                    "atr_pips": technical.atr_pips,
                    "sentiment": sentiment.sentiment_score,
                    "rag_warnings": rag_warnings,
                    "bull_case": confidence_result.bull_case,
                    "bear_case": confidence_result.bear_case
                }
            })

            # 9.6. Check if learning engine recommends NOT trading
            if not learning_insights.should_trade:
                skip_reason = f"Learning blocked: {', '.join(learning_insights.warnings[:2])}"
                logger.warning(f"{instrument}: Blocked by learning - {skip_reason}")
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "direction": direction,
                    "confidence": confidence_result.confidence_score,
                    "decision": "LEARNING_BLOCKED",
                    "reasoning": f"Learning engine blocked trade: {skip_reason}",
                    "details": {
                        "original_confidence": original_confidence,
                        "adjusted_confidence": adjusted_confidence,
                        "learning_adjustment": learning_insights.confidence_adjustment,
                        "warnings": learning_insights.warnings,
                        "adjustment_reasons": learning_insights.adjustment_reasons
                    }
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 10. Check if meets threshold (uses learning mode active settings)
            active_threshold = self.config.get_active_threshold()
            if confidence_result.confidence_score < active_threshold:
                mode_label = "LEARNING" if self.config.learning_mode.is_in_learning() else "PRODUCTION"
                skip_reason = f"Confidence {confidence_result.confidence_score}% < {active_threshold}% [{mode_label}]"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "direction": direction,
                    "confidence": confidence_result.confidence_score,
                    "decision": "SKIP",
                    "reasoning": f"{skip_reason} - Below threshold. Bull: {confidence_result.bull_case[:50]}... Bear: {confidence_result.bear_case[:50]}...",
                    "details": {
                        "confidence": confidence_result.confidence_score,
                        "threshold": active_threshold,
                        "learning_mode": self.config.learning_mode.is_in_learning(),
                        "learning_progress": f"{self.config.learning_mode.current_trades}/{self.config.learning_mode.target_trades}",
                        "original_confidence": original_confidence,
                        "learning_adjustment": learning_insights.confidence_adjustment,
                        "bull_case": confidence_result.bull_case,
                        "bear_case": confidence_result.bear_case
                    }
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 10.5 Run filter chain (Self-Upgrade System)
            filter_chain_result = self._run_filter_chain(
                instrument=instrument,
                direction=direction,
                confidence=confidence_result.confidence_score,
                technical=technical,
                sentiment=sentiment
            )
            if not filter_chain_result.passed:
                skip_reason = f"Filter: {filter_chain_result.reason}"
                db.log_activity({
                    "activity_type": "SIGNAL_REJECTED",
                    "instrument": instrument,
                    "direction": direction,
                    "confidence": confidence_result.confidence_score,
                    "decision": "FILTER_BLOCKED",
                    "reasoning": skip_reason,
                    "details": {
                        "blocking_filter": filter_chain_result.blocking_filter,
                        "filters_run": filter_chain_result.filters_run,
                        "total_filters": filter_chain_result.total_filters
                    }
                })
                return ScanResult(
                    instrument=instrument,
                    has_signal=False,
                    skip_reason=skip_reason,
                    scan_duration_ms=self._get_duration_ms(start_time)
                )

            # 11. Check scalping criteria if in scalping mode
            if self.config.mode == "scalping":
                scalping_ok, scalping_reason = self._check_scalping_criteria(
                    technical, price, instrument
                )
                if not scalping_ok:
                    skip_reason = f"Scalping criteria: {scalping_reason}"

                    # Try AI Override for scalping criteria (ATR)
                    override_result = self._evaluate_override(
                        instrument=instrument,
                        direction=direction,
                        skip_reason=skip_reason,
                        confidence=confidence_result.confidence_score,
                        technical=technical,
                        sentiment=sentiment,
                        price=price,
                        htf_technical=htf_technical
                    )

                    if override_result and override_result.get("adjustment"):
                        adj = override_result["adjustment"]
                        original_values = self._apply_temporary_override(adj.setting_name, adj.new_value)
                        logger.info(f"AI_OVERRIDE_APPLIED | {instrument} | Relaxed {adj.setting_name} to {adj.new_value}")

                        # Re-check scalping criteria with relaxed settings
                        scalping_ok, _ = self._check_scalping_criteria(technical, price, instrument)

                        # Restore original settings
                        self._restore_original_settings(original_values)

                        if scalping_ok:
                            # Continue processing - override successful
                            pass
                        else:
                            # Override didn't help
                            db.log_activity({
                                "activity_type": "SIGNAL_REJECTED",
                                "instrument": instrument,
                                "direction": direction,
                                "confidence": confidence_result.confidence_score,
                                "decision": "SKIP",
                                "reasoning": skip_reason,
                                "details": {
                                    "scalping_check": scalping_reason,
                                    "atr_pips": technical.atr_pips,
                                    "override_attempted": True,
                                    "override_result": "FAILED"
                                }
                            })
                            return ScanResult(
                                instrument=instrument,
                                has_signal=False,
                                skip_reason=skip_reason,
                                scan_duration_ms=self._get_duration_ms(start_time)
                            )
                    else:
                        db.log_activity({
                            "activity_type": "SIGNAL_REJECTED",
                            "instrument": instrument,
                            "direction": direction,
                            "confidence": confidence_result.confidence_score,
                            "decision": "SKIP",
                            "reasoning": skip_reason,
                            "details": {"scalping_check": scalping_reason, "atr_pips": technical.atr_pips}
                        })
                        return ScanResult(
                            instrument=instrument,
                            has_signal=False,
                            skip_reason=skip_reason,
                            scan_duration_ms=self._get_duration_ms(start_time)
                        )

            # 12. Calculate SL/TP
            entry_price = price["ask"] if direction == "LONG" else price["bid"]
            sl, tp = self._calculate_sl_tp(entry_price, direction, technical, instrument)

            # 13. Calculate R:R
            risk = abs(entry_price - sl)
            reward = abs(tp - entry_price)
            risk_reward = reward / risk if risk > 0 else 0

            # Use small tolerance for float comparison
            if risk_reward < self.config.scalping.target_rr - 0.01:
                skip_reason = f"R:R {risk_reward:.2f} < {self.config.scalping.target_rr}"

                # Try AI Override for R:R
                override_result = self._evaluate_override(
                    instrument=instrument,
                    direction=direction,
                    skip_reason=skip_reason,
                    confidence=confidence_result.confidence_score,
                    technical=technical,
                    sentiment=sentiment,
                    price=price,
                    htf_technical=htf_technical
                )

                if override_result and override_result.get("adjustment"):
                    adj = override_result["adjustment"]
                    if adj.setting_name == "target_rr":
                        # Check if current R:R meets the adjusted threshold
                        adjusted_rr = TunableSettings.get_safe_value("target_rr", adj.new_value)
                        if risk_reward >= adjusted_rr - 0.01:
                            logger.info(f"AI_OVERRIDE_APPLIED | {instrument} | R:R {risk_reward:.2f} accepted (threshold lowered to {adjusted_rr:.2f})")
                            # Continue processing - R:R now acceptable
                        else:
                            # Even with override, R:R still too low
                            db.log_activity({
                                "activity_type": "SIGNAL_REJECTED",
                                "instrument": instrument,
                                "direction": direction,
                                "confidence": confidence_result.confidence_score,
                                "decision": "SKIP",
                                "reasoning": skip_reason,
                                "details": {
                                    "risk_reward": risk_reward,
                                    "target_rr": self.config.scalping.target_rr,
                                    "override_attempted": True,
                                    "override_result": "FAILED"
                                }
                            })
                            return ScanResult(
                                instrument=instrument,
                                has_signal=False,
                                skip_reason=skip_reason,
                                scan_duration_ms=self._get_duration_ms(start_time)
                            )
                    else:
                        # Wrong adjustment type for this rejection
                        db.log_activity({
                            "activity_type": "SIGNAL_REJECTED",
                            "instrument": instrument,
                            "direction": direction,
                            "confidence": confidence_result.confidence_score,
                            "decision": "SKIP",
                            "reasoning": skip_reason,
                            "details": {"risk_reward": risk_reward, "target_rr": self.config.scalping.target_rr}
                        })
                        return ScanResult(
                            instrument=instrument,
                            has_signal=False,
                            skip_reason=skip_reason,
                            scan_duration_ms=self._get_duration_ms(start_time)
                        )
                else:
                    db.log_activity({
                        "activity_type": "SIGNAL_REJECTED",
                        "instrument": instrument,
                        "direction": direction,
                        "confidence": confidence_result.confidence_score,
                        "decision": "SKIP",
                        "reasoning": skip_reason,
                        "details": {"risk_reward": risk_reward, "target_rr": self.config.scalping.target_rr}
                    })
                    return ScanResult(
                        instrument=instrument,
                        has_signal=False,
                        skip_reason=skip_reason,
                        scan_duration_ms=self._get_duration_ms(start_time)
                    )

            # 14. Create signal
            signal = TradingSignal(
                instrument=instrument,
                direction=direction,
                confidence=confidence_result.confidence_score,
                entry_price=entry_price,
                stop_loss=sl,
                take_profit=tp,
                risk_reward=risk_reward,
                technical=technical,
                sentiment=sentiment,
                confidence_result=confidence_result,
                scan_duration_ms=self._get_duration_ms(start_time),
                reason=f"{direction} signal: {technical.trend}, RSI={technical.rsi:.0f}"
            )

            # Log with learning info
            learning_msg = ""
            if learning_insights.confidence_adjustment != 0:
                learning_msg = f" [Learning: {learning_insights.confidence_adjustment:+d}%]"
            logger.info(f"Signal found: {instrument} {direction} conf={confidence_result.confidence_score}%{learning_msg}")

            # Log signal generated
            db.log_activity({
                "activity_type": "SIGNAL_GENERATED",
                "instrument": instrument,
                "direction": direction,
                "technical_score": confidence_result.technical_score,
                "sentiment_score": sentiment.sentiment_score,
                "confidence": confidence_result.confidence_score,
                "decision": "SIGNAL",
                "reasoning": f"Valid {direction} signal! Entry: {entry_price:.5f}, SL: {sl:.5f}, TP: {tp:.5f}, R:R: {risk_reward:.2f}{learning_msg}",
                "details": {
                    "entry_price": entry_price,
                    "stop_loss": sl,
                    "take_profit": tp,
                    "risk_reward": risk_reward,
                    "trend": technical.trend,
                    "rsi": technical.rsi,
                    "atr_pips": technical.atr_pips,
                    "market_regime": technical.market_regime,
                    "regime_strength": technical.regime_strength,
                    "adx": technical.adx,
                    "bull_case": confidence_result.bull_case,
                    "bear_case": confidence_result.bear_case,
                    "learning_adjustment": learning_insights.confidence_adjustment,
                    "learning_warnings": learning_insights.warnings,
                    "learning_positive": learning_insights.positive_signals
                },
                "duration_ms": self._get_duration_ms(start_time)
            })

            # Save signal to auto_signals table for dashboard tracking
            db.log_auto_signal({
                "timestamp": signal.timestamp.isoformat(),
                "instrument": instrument,
                "direction": direction,
                "confidence": confidence_result.confidence_score,
                "entry_price": entry_price,
                "stop_loss": sl,
                "take_profit": tp,
                "risk_reward": risk_reward,
                "executed": 0,  # Will be updated by executor
                "skip_reason": None,
                "trade_id": None
            })

            return ScanResult(
                instrument=instrument,
                has_signal=True,
                signal=signal,
                scan_duration_ms=self._get_duration_ms(start_time)
            )

        except MT5Error as e:
            db.log_activity({
                "activity_type": "ERROR",
                "instrument": instrument,
                "reasoning": f"MT5 error: {str(e)}"
            })
            return ScanResult(
                instrument=instrument,
                has_signal=False,
                error=f"MT5 error: {e}",
                scan_duration_ms=self._get_duration_ms(start_time)
            )
        except Exception as e:
            logger.exception(f"Scan error for {instrument}")
            db.log_activity({
                "activity_type": "ERROR",
                "instrument": instrument,
                "reasoning": f"Scan error: {str(e)}"
            })
            return ScanResult(
                instrument=instrument,
                has_signal=False,
                error=str(e),
                scan_duration_ms=self._get_duration_ms(start_time)
            )

    def _check_spread(self, price: dict, instrument: str) -> bool:
        """
        Check if spread is acceptable for trading.

        Uses per-instrument spread limits from instrument_profiles.json
        with fallback to config default.
        """
        # Get instrument-specific spread limit
        profile = get_profile(instrument)
        max_spread = profile.get("max_spread_pips", self.config.scalping.max_spread_pips)

        return price.get("spread_pips", 999) <= max_spread

    def _check_market_regime(
        self,
        technical: TechnicalAnalysis,
        instrument: str
    ) -> tuple[bool, str]:
        """
        Check if market regime is suitable for trading.

        Conservative approach for Phase 1:
        - LOW_VOLATILITY: Block (no movement = no profit potential)
        - VOLATILE: Block (too risky for scalping)
        - TRENDING: Allow only with-trend trades
        - RANGING: Allow at S/R levels

        Args:
            technical: Technical analysis with regime data
            instrument: Instrument symbol

        Returns:
            (is_ok, reason)
        """
        regime = technical.market_regime
        strength = technical.regime_strength

        # Block LOW_VOLATILITY - no scalping opportunity
        if regime == "LOW_VOLATILITY" and strength >= 60:
            return False, f"Low volatility squeeze (ADX={technical.adx:.1f}, BB width={technical.bollinger_width:.2f}%)"

        # Block VOLATILE - too risky for scalping
        if regime == "VOLATILE" and strength >= 65:
            return False, f"High volatility ({technical.bollinger_width_percentile:.0f}th percentile, ADX={technical.adx:.1f})"

        # RANGING - check if near S/R for bounce plays
        if regime == "RANGING":
            near_sr = self._is_near_support_resistance(technical)
            if not near_sr and strength >= 70:
                return False, f"Ranging market but not at S/R (ADX={technical.adx:.1f})"

        # TRENDING - we'll check direction alignment later in MTF check
        # For now just log that we're in a trending regime
        if regime == "TRENDING":
            logger.debug(f"{instrument}: Trending regime (ADX={technical.adx:.1f}, strength={strength}%)")

        return True, "OK"

    def _is_near_support_resistance(self, technical: TechnicalAnalysis) -> bool:
        """
        Check if price is near a support or resistance level.

        For ranging markets, we want to trade bounces at S/R levels.

        Returns:
            True if within 15 pips of S/R
        """
        NEAR_SR_THRESHOLD_PIPS = 15

        near_support = (
            technical.distance_to_support_pips is not None and
            technical.distance_to_support_pips <= NEAR_SR_THRESHOLD_PIPS
        )

        near_resistance = (
            technical.distance_to_resistance_pips is not None and
            technical.distance_to_resistance_pips <= NEAR_SR_THRESHOLD_PIPS
        )

        return near_support or near_resistance

    def _determine_direction(
        self,
        technical: TechnicalAnalysis,
        sentiment: SentimentResult
    ) -> Optional[str]:
        """
        Determine trade direction based on analysis.

        Returns:
            "LONG", "SHORT", or None if no clear direction
        """
        # Count bullish/bearish signals
        bullish = 0
        bearish = 0

        # Trend
        if technical.trend == "BULLISH":
            bullish += 2
        elif technical.trend == "BEARISH":
            bearish += 2

        # RSI
        if technical.rsi < 30:
            bullish += 1  # Oversold = potential long
        elif technical.rsi > 70:
            bearish += 1  # Overbought = potential short

        # MACD
        if technical.macd_trend == "BULLISH":
            bullish += 1
        elif technical.macd_trend == "BEARISH":
            bearish += 1

        # Sentiment
        if sentiment.sentiment_score > 0.3:
            bullish += 1
        elif sentiment.sentiment_score < -0.3:
            bearish += 1

        # Need clear direction
        if bullish >= 3 and bullish > bearish:
            return "LONG"
        elif bearish >= 3 and bearish > bullish:
            return "SHORT"

        return None

    def _is_in_killzone(self) -> tuple[bool, str]:
        """
        Check if current time is in a high-probability killzone.

        Killzones are periods of high liquidity and volatility:
        - London Open: 07:00-09:00 UTC
        - NY Open: 12:00-14:00 UTC (overlap with London)
        - London Close: 15:00-17:00 UTC

        Returns:
            (is_in_killzone, killzone_name)
        """
        now = datetime.now(timezone.utc)
        hour = now.hour

        # London Open Killzone
        if 7 <= hour < 9:
            return True, "LONDON_OPEN"

        # NY Open Killzone (London/NY overlap)
        if 12 <= hour < 14:
            return True, "NY_OPEN"

        # London Close Killzone
        if 15 <= hour < 17:
            return True, "LONDON_CLOSE"

        return False, ""

    def _confirm_mtf_trend(
        self,
        ltf: TechnicalAnalysis,
        htf: TechnicalAnalysis
    ) -> tuple[bool, str]:
        """
        Confirm multi-timeframe trend alignment.

        For scalping, we want the lower timeframe (M5) direction
        to align with the higher timeframe (H1) trend.

        Rules:
        - LONG only if H1 is BULLISH or RANGING
        - SHORT only if H1 is BEARISH or RANGING
        - If H1 strongly opposes LTF direction, skip

        Args:
            ltf: Lower timeframe (M5) analysis
            htf: Higher timeframe (H1) analysis

        Returns:
            (is_aligned, reason)
        """
        # Determine LTF direction
        ltf_direction = None
        if ltf.trend == "BULLISH" or (ltf.macd_trend == "BULLISH" and ltf.rsi < 70):
            ltf_direction = "LONG"
        elif ltf.trend == "BEARISH" or (ltf.macd_trend == "BEARISH" and ltf.rsi > 30):
            ltf_direction = "SHORT"

        if ltf_direction is None:
            return True, "OK"  # No clear direction, continue analysis

        # Check HTF alignment - CONSERVATIVE MODE: require trend alignment
        if ltf_direction == "LONG":
            # For LONG, HTF should be BULLISH or RANGING
            if htf.trend == "BEARISH" and htf.trend_strength > 55:
                return False, f"M5=BULLISH but H1=BEARISH({htf.trend_strength:.0f}%)"
            # Also check MACD alignment
            if htf.macd_trend == "BEARISH" and htf.trend == "BEARISH":
                return False, f"M5=BULLISH but H1 MACD+Trend=BEARISH"

        elif ltf_direction == "SHORT":
            # For SHORT, HTF should be BEARISH or RANGING
            if htf.trend == "BULLISH" and htf.trend_strength > 55:
                return False, f"M5=BEARISH but H1=BULLISH({htf.trend_strength:.0f}%)"
            if htf.macd_trend == "BULLISH" and htf.trend == "BULLISH":
                return False, f"M5=BEARISH but H1 MACD+Trend=BULLISH"

        return True, "OK"

    def _check_scalping_criteria(
        self,
        technical: TechnicalAnalysis,
        price: dict,
        instrument: str
    ) -> tuple[bool, str]:
        """
        Check scalping-specific criteria.

        Returns:
            (is_ok, reason)
        """
        scalping = self.config.scalping

        # Check ATR (volatility)
        if technical.atr_pips < scalping.min_atr_pips:
            return False, f"ATR too low: {technical.atr_pips:.1f} < {scalping.min_atr_pips}"

        # Check session (simplified - full implementation would check actual time)
        # TODO: Add proper session filtering

        return True, "OK"

    def _calculate_sl_tp(
        self,
        entry: float,
        direction: str,
        technical: TechnicalAnalysis,
        instrument: str
    ) -> tuple[float, float]:
        """
        Calculate stop loss and take profit for scalping.

        Returns:
            (stop_loss, take_profit)
        """
        scalping = self.config.scalping

        # Get pip value
        pip_value = 0.0001 if "JPY" not in instrument else 0.01

        # Use ATR-based SL, capped at max
        sl_pips = min(technical.atr_pips * 1.5, scalping.max_sl_pips)
        tp_pips = sl_pips * scalping.target_rr

        if direction == "LONG":
            sl = entry - (sl_pips * pip_value)
            tp = entry + (tp_pips * pip_value)
        else:
            sl = entry + (sl_pips * pip_value)
            tp = entry - (tp_pips * pip_value)

        return sl, tp

    def _get_duration_ms(self, start_time: datetime) -> int:
        """Calculate duration in milliseconds."""
        return int((datetime.now(timezone.utc) - start_time).total_seconds() * 1000)

    def _evaluate_override(
        self,
        instrument: str,
        direction: str,
        skip_reason: str,
        confidence: int,
        technical: TechnicalAnalysis,
        sentiment: SentimentResult,
        price: dict,
        htf_technical: Optional[TechnicalAnalysis] = None
    ) -> Optional[Dict[str, Any]]:
        """
        Evaluate if a rejected signal should be overridden by AI.

        Args:
            instrument: Instrument symbol
            direction: Trade direction
            skip_reason: Reason for rejection
            confidence: Confidence score
            technical: Technical analysis
            sentiment: Sentiment analysis
            price: Current price data
            htf_technical: Higher timeframe technical data (optional)

        Returns:
            Dict with override result and adjusted settings, or None
        """
        if not self.override_evaluator.can_override(skip_reason):
            return None

        # Build context for AI
        context = OverrideContext(
            instrument=instrument,
            direction=direction,
            skip_reason=skip_reason,
            confidence=confidence,
            technical_data={
                "trend": technical.trend,
                "trend_strength": getattr(technical, "trend_strength", 0),
                "rsi": technical.rsi,
                "macd_trend": technical.macd_trend,
                "atr_pips": technical.atr_pips,
            },
            sentiment_score=sentiment.sentiment_score,
            spread_pips=price.get("spread_pips", 0),
            atr_pips=technical.atr_pips,
        )

        # Build signal data for AI
        signal_data = {
            "price": price.get("mid", price.get("bid", 0)),
            "rsi": technical.rsi,
            "macd_trend": technical.macd_trend,
            "m5_trend": technical.trend,
            "h1_trend": htf_technical.trend if htf_technical else "N/A",
            "h1_strength": getattr(htf_technical, "trend_strength", 0) if htf_technical else 0,
            "tech_score": getattr(technical, "trend_strength", 50),
            "sentiment_score": sentiment.sentiment_score,
            "adv_score": 50,  # Default if not available
        }

        logger.info(f"AI_OVERRIDE_EVAL | {instrument} | Evaluating override for: {skip_reason}")

        result = self.override_evaluator.evaluate_override(context, signal_data, skip_reason)

        if result is None:
            return None

        if result.override_recommended:
            logger.info(
                f"AI_OVERRIDE_APPROVED | {instrument} | confidence={result.ai_confidence}% "
                f"| {result.reasoning[:80]}"
            )
            if result.suggested_adjustment:
                logger.info(
                    f"AI_OVERRIDE_ADJUSTMENT | {instrument} | "
                    f"{result.suggested_adjustment.setting_name}: "
                    f"{result.suggested_adjustment.original_value} -> {result.suggested_adjustment.new_value}"
                )

            return {
                "override_result": result,
                "adjustment": result.suggested_adjustment,
            }
        else:
            logger.info(
                f"AI_OVERRIDE_REJECTED | {instrument} | confidence={result.ai_confidence}% "
                f"| {result.reasoning[:80]}"
            )
            return None

    def _apply_temporary_override(
        self,
        adjustment_setting: str,
        adjustment_value: Any
    ) -> Dict[str, Any]:
        """
        Apply a temporary override to settings.

        Returns the original values so they can be restored.
        """
        original_values = {}

        if adjustment_setting == "max_spread_pips":
            original_values["max_spread_pips"] = self.config.scalping.max_spread_pips
            self.config.scalping.max_spread_pips = float(adjustment_value)

        elif adjustment_setting == "min_atr_pips":
            original_values["min_atr_pips"] = self.config.scalping.min_atr_pips
            self.config.scalping.min_atr_pips = float(adjustment_value)

        elif adjustment_setting == "target_rr":
            original_values["target_rr"] = self.config.scalping.target_rr
            self.config.scalping.target_rr = float(adjustment_value)

        elif adjustment_setting == "min_confidence_threshold":
            original_values["min_confidence_threshold"] = self.config.min_confidence_threshold
            self.config.min_confidence_threshold = int(adjustment_value)

        elif adjustment_setting == "mtf_strength_threshold":
            # This is used in _confirm_mtf_trend - store for reference
            original_values["mtf_strength_threshold"] = 60  # Default
            # Note: actual MTF threshold is hardcoded in _confirm_mtf_trend

        return original_values

    def _restore_original_settings(self, original_values: Dict[str, Any]):
        """Restore settings to original values after override attempt."""
        for setting, value in original_values.items():
            if setting == "max_spread_pips":
                self.config.scalping.max_spread_pips = value
            elif setting == "min_atr_pips":
                self.config.scalping.min_atr_pips = value
            elif setting == "target_rr":
                self.config.scalping.target_rr = value
            elif setting == "min_confidence_threshold":
                self.config.min_confidence_threshold = value

    def _run_filter_chain(
        self,
        instrument: str,
        direction: str,
        confidence: int,
        technical: TechnicalAnalysis,
        sentiment: SentimentResult
    ):
        """
        Run the filter chain from the Self-Upgrade System.

        Args:
            instrument: Instrument symbol
            direction: Trade direction
            confidence: Confidence score
            technical: Technical analysis
            sentiment: Sentiment analysis

        Returns:
            FilterChainResult from the registry
        """
        # Build signal data for filters
        signal_data = {
            "instrument": instrument,
            "direction": direction,
            "confidence": confidence,
            "technical": {
                "trend": technical.trend,
                "trend_strength": getattr(technical, "trend_strength", 0),
                "rsi": technical.rsi,
                "macd_trend": technical.macd_trend,
                "atr_pips": technical.atr_pips,
                "market_regime": technical.market_regime,
                "regime_strength": technical.regime_strength,
                "adx": technical.adx,
            },
            "market_regime": technical.market_regime,
            "regime_strength": technical.regime_strength,
            "sentiment": sentiment.sentiment_score,
            "timestamp": datetime.now(timezone.utc),
        }

        # Determine session
        hour = datetime.now(timezone.utc).hour
        if 7 <= hour < 16:
            signal_data["session"] = "london"
        elif 12 <= hour < 21:
            signal_data["session"] = "newyork"
        elif 0 <= hour < 9:
            signal_data["session"] = "tokyo"
        else:
            signal_data["session"] = "sydney"

        # Run all filters
        return self.filter_registry.run_all_filters(signal_data)

    def get_scan_summary(self) -> dict:
        """Get summary of scanner configuration."""
        return {
            "instruments": self.config.instruments,
            "mode": self.config.mode,
            "min_confidence": self.config.min_confidence_threshold,
            "scan_interval": self.config.scan_interval_seconds,
            "scalping_config": {
                "max_sl_pips": self.config.scalping.max_sl_pips,
                "target_rr": self.config.scalping.target_rr,
                "max_spread_pips": self.config.scalping.max_spread_pips
            }
        }
